# File: cnn_to_quantum_transferability.py
# Author: Muhammad Haffi Khalid
# Date: April 2025

# Purpose:
#     This script tests transferability of FGSM adversarial examples generated by a CNN
#     to quantum classifiers (amplitude or reupload embeddings).
#
#     For each ε ∈ [0, 1] with step 0.05:
#       - FGSM examples are generated by CNN
#       - Each set is evaluated by the selected quantum classifier
#       - Accuracy and MSE loss are recorded and plotted
#
#     Output:
#       - Saves CSV with adversarial samples for each epsilon
#       - Saves accuracy/loss plots and metrics
#       - Folder: C:/Users/ASDF/Desktop/part-2_fyp/Transfer/CNN_vs_Quantum/{embedding}

import os
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from tensorflow.keras.models import load_model

# === CONFIGURATION ===
embedding = "amplitude"  # Options: "amplitude" or "reupload"
epsilons = np.round(np.arange(0, 1.0001, 0.05), 2)

# === PATHS ===
base = r"C:\Users\ASDF\Desktop\part-2_fyp"
cnn_model_path = os.path.join(base, "weights", "cnn", f"cnn_{embedding}_clean.h5")
quantum_weights_path = os.path.join(base, "weights", embedding, f"{embedding}_10layers_clean.npy")
quantum_test_csv = os.path.join(base, "data", embedding, f"banknote_{embedding}_preprocessed_test.csv")
output_dir = os.path.join(base, "Transfer", "CNN_vs_Quantum", embedding)
os.makedirs(output_dir, exist_ok=True)

# === LOAD DATA ===
df = pd.read_csv(quantum_test_csv)
X_test = df[["variance", "skewness", "curtosis", "entropy"]].values.astype(np.float32)
y_test = df["class"].apply(lambda x: -1.0 if x == 0 else 1.0).values.astype(np.float32)

# === LOAD MODELS ===
cnn = load_model(cnn_model_path)
quantum_weights = np.load(quantum_weights_path, allow_pickle=True)

if embedding == "amplitude":
    from models.quantum_model_amplitude import quantum_classifier_amplitude as quantum_classifier
elif embedding == "reupload":
    from models.quantum_model_reupload import quantum_classifier_reupload as quantum_classifier
else:
    raise ValueError("Embedding must be 'amplitude' or 'reupload'.")

# === FGSM FUNCTION ===
def fgsm_attack(model, x, y, epsilon):
    import tensorflow as tf
    x_tensor = tf.convert_to_tensor([x])
    y_tensor = tf.convert_to_tensor([y])
    with tf.GradientTape() as tape:
        tape.watch(x_tensor)
        prediction = model(x_tensor, training=False)
        loss = tf.keras.losses.MSE(y_tensor, prediction)
    gradient = tape.gradient(loss, x_tensor)
    signed_grad = tf.sign(gradient)
    adv = x_tensor + epsilon * signed_grad
    return adv.numpy()[0]

# === STORAGE ===
acc_eps, loss_eps = [], []

# === MAIN LOOP ===
for eps in epsilons:
    print(f"[INFO] Epsilon: {eps:.2f}")
    adv_examples = []
    preds, labels = [], []

    for x, y in zip(X_test, y_test):
        x_adv = fgsm_attack(cnn, x, y, eps)
        pred = quantum_classifier(quantum_weights, x_adv)
        label = 1.0 if pred >= 0 else -1.0
        preds.append(pred)
        labels.append(y)
        adv_examples.append(np.append(x_adv, y))

    # Metrics
    acc = np.mean([int(np.sign(p) == np.sign(y)) for p, y in zip(preds, labels)])
    mse = np.mean([(p - y) ** 2 for p, y in zip(preds, labels)])
    acc_eps.append(acc)
    loss_eps.append(mse)

    # Save adversarial samples
    adv_df = pd.DataFrame(adv_examples, columns=["variance", "skewness", "curtosis", "entropy", "class"])
    adv_df.to_csv(os.path.join(output_dir, f"fgsm_eps_{eps:.2f}.csv"), index=False)

# === SAVE METRICS ===
metrics_df = pd.DataFrame({
    "epsilon": epsilons,
    "accuracy": acc_eps,
    "loss": loss_eps
})
metrics_df.to_csv(os.path.join(output_dir, "cnn_to_quantum_metrics.csv"), index=False)

# === PLOTS ===
plt.figure()
plt.plot(epsilons, acc_eps, marker='o', label='Accuracy')
plt.title(f"CNN → Quantum ({embedding}) Accuracy vs Epsilon")
plt.xlabel("Epsilon")
plt.ylabel("Accuracy")
plt.grid(True)
plt.savefig(os.path.join(output_dir, "accuracy_vs_epsilon.png"))
plt.close()

plt.figure()
plt.plot(epsilons, loss_eps, marker='o', label='Loss')
plt.title(f"CNN → Quantum ({embedding}) Loss vs Epsilon")
plt.xlabel("Epsilon")
plt.ylabel("MSE Loss")
plt.grid(True)
plt.savefig(os.path.join(output_dir, "loss_vs_epsilon.png"))
plt.close()

print(f"[✓] All results saved to {output_dir}")
